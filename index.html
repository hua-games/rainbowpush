<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Rainbow Quest - Unicorn Puzzle Game</title>
  <meta name="description" content="Guide your unicorn through 7 magical levels collecting rainbow crystals in this delightful Sokoban-style puzzle game!">

  <!-- Open Graph / Facebook -->
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://happyunicornarmy.com/rainbow-quest">
  <meta property="og:title" content="Rainbow Quest - Unicorn Puzzle Game">
  <meta property="og:description" content="Guide your unicorn through 7 magical levels collecting rainbow crystals in this delightful Sokoban-style puzzle game!">
  <meta property="og:image" content="graphics/unicorn.png">

  <!-- Twitter -->
  <meta property="twitter:card" content="summary_large_image">
  <meta property="twitter:url" content="https://happyunicornarmy.com/rainbow-quest">
  <meta property="twitter:title" content="Rainbow Quest - Unicorn Puzzle Game">
  <meta property="twitter:description" content="Guide your unicorn through 7 magical levels collecting rainbow crystals in this delightful Sokoban-style puzzle game!">
  <meta property="twitter:image" content="graphics/unicorn.png">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    @keyframes rainbowBackground {
      0% { background: linear-gradient(135deg, #f44336 0%, #ff9800 100%); }
      14% { background: linear-gradient(135deg, #ff9800 0%, #ffc107 100%); }
      28% { background: linear-gradient(135deg, #ffc107 0%, #4caf50 100%); }
      43% { background: linear-gradient(135deg, #4caf50 0%, #2196f3 100%); }
      57% { background: linear-gradient(135deg, #2196f3 0%, #3F51B5 100%); }
      71% { background: linear-gradient(135deg, #3F51B5 0%, #9c27b0 100%); }
      86% { background: linear-gradient(135deg, #9c27b0 0%, #f44336 100%); }
      100% { background: linear-gradient(135deg, #f44336 0%, #ff9800 100%); }
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      display: flex;
      justify-content: center;
      align-items: flex-start;
      min-height: 100vh;
      color: white;
      padding: 10px 20px 20px 20px;
    }

    body.rainbow-victory {
      animation: rainbowBackground 10s ease-in-out infinite;
    }

    #game {
      text-align: center;
      max-width: 100%;
    }

    #ui {
      background: rgba(0, 0, 0, 0.3);
      padding: 10px;
      border-radius: 15px;
      margin-top: 5px;
      margin-bottom: 10px;
      backdrop-filter: blur(10px);
    }

    h1 {
      font-size: 1.6em;
      margin-bottom: 5px;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
      position: relative;
      padding-left: 75px;
    }

    h1 img {
      position: absolute;
      left: 0;
      top: 50%;
      transform: translateY(calc(-50% + 14px));
      height: 2.6em;
    }

    .site-link {
      position: absolute;
      right: 0;
      top: calc(100% - 5px);
      font-size: 0.55em;
      background: linear-gradient(to right, #f44336, #ff9800, #ffc107, #4caf50, #2196f3, #e91e9e);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      text-decoration: none;
      font-weight: normal;
      filter: drop-shadow(1px 1px 1px rgba(0, 0, 0, 0.5));
    }

    .site-link:hover {
      color: rgba(255, 255, 255, 0.9);
    }

    #levelInfo {
      font-size: 1.1em;
      margin: 22px 0 5px 0;
      opacity: 0.9;
    }

    #stats {
      font-size: 1.3em;
      margin: 8px 0;
      font-weight: bold;
    }

    .button-group {
      display: flex;
      gap: 8px;
      justify-content: center;
      flex-wrap: nowrap;
    }

    button {
      background: #9b59d0;
      color: white;
      border: none;
      padding: 6px 14px;
      border-radius: 8px;
      font-size: 0.9em;
      cursor: pointer;
      font-weight: bold;
      transition: all 0.2s;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
      white-space: nowrap;
    }

    button:hover {
      background: #8849c0;
      transform: translateY(-2px);
      box-shadow: 0 6px 8px rgba(0, 0, 0, 0.3);
    }

    button:active {
      transform: translateY(0);
    }

    button:disabled {
      background: #666;
      cursor: not-allowed;
      transform: none;
    }

    #grid {
      display: grid;
      gap: 4px;
      background: rgba(0, 0, 0, 0.3);
      padding: 10px;
      border-radius: 15px;
      margin: auto;
      width: fit-content;
      box-shadow: 0 8px 16px rgba(0, 0, 0, 0.4);
      justify-items: center;
    }

    #game {
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      min-height: calc(100vh - 200px);
    }

    .tile {
      width: 45px;
      height: 45px;
      background: #e8f4f8;
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 3px;
      transition: background 0.2s;
    }

    .tile.wall {
      background: #555;
      box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.5);
    }

    .tile.water {
      background: linear-gradient(135deg, #4fc3f7 0%, #29b6f6 100%);
      box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.2);
    }

    .tile.ice {
      background: linear-gradient(135deg, #e1f5fe 0%, #b3e5fc 100%);
      box-shadow: inset 0 2px 4px rgba(255, 255, 255, 0.5);
    }

    .restore-point {
      position: absolute;
      width: 32px;
      height: 32px;
      border-radius: 50%;
      border: 3px dashed;
      opacity: 0.6;
      animation: pulse 2s ease-in-out infinite;
    }

    @keyframes pulse {
      0%, 100% { transform: scale(1); opacity: 0.6; }
      50% { transform: scale(1.1); opacity: 0.8; }
    }

    .restore-point.active {
      border-style: solid;
      opacity: 1;
      animation: none;
      box-shadow: 0 0 10px currentColor;
    }

    .restore-point.red { border-color: #f44336; color: #f44336; }
    .restore-point.orange { border-color: #ff9800; color: #ff9800; }
    .restore-point.yellow { border-color: #ffc107; color: #ffc107; }
    .restore-point.green { border-color: #4caf50; color: #4caf50; }
    .restore-point.blue { border-color: #2196f3; color: #2196f3; }
    .restore-point.indigo { border-color: #3F51B5; color: #3F51B5; }
    .restore-point.violet { border-color: #9c27b0; color: #9c27b0; }

    .crystal {
      position: absolute;
      width: 36px;
      height: 36px;
      border-radius: 50%;
      z-index: 2;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
      border: 2px solid rgba(255, 255, 255, 0.3);
    }

    .crystal.red { background: radial-gradient(circle at 30% 30%, #ff6b6b, #f44336); }
    .crystal.orange { background: radial-gradient(circle at 30% 30%, #ffb74d, #ff9800); }
    .crystal.yellow { background: radial-gradient(circle at 30% 30%, #ffd54f, #ffc107); }
    .crystal.green { background: radial-gradient(circle at 30% 30%, #81c784, #4caf50); }
    .crystal.blue { background: radial-gradient(circle at 30% 30%, #64b5f6, #2196f3); }
    .crystal.indigo { background: radial-gradient(circle at 30% 30%, #7986CB, #3F51B5); }
    .crystal.violet { background: radial-gradient(circle at 30% 30%, #ba68c8, #9c27b0); }

    .crystal.activated {
      animation: sparkle 0.5s ease-out;
    }

    @keyframes sparkle {
      0% { transform: scale(1); }
      50% { transform: scale(1.3); box-shadow: 0 0 20px currentColor; }
      100% { transform: scale(1); }
    }

    .player {
      width: 60px;
      height: 60px;
      z-index: 3;
      filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
      position: absolute;
      object-fit: contain;
    }

    #victory {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.95);
      padding: 20px;
      border-radius: 15px;
      border: 3px solid #9b59d0;
      z-index: 100;
      min-width: 280px;
      max-width: 90vw;
      box-shadow: 0 0 40px rgba(155, 89, 208, 0.6);
      animation: victoryAppear 0.5s ease-out;
    }

    @keyframes victoryAppear {
      from {
        transform: translate(-50%, -50%) scale(0.5);
        opacity: 0;
      }
      to {
        transform: translate(-50%, -50%) scale(1);
        opacity: 1;
      }
    }

    #victory h2 {
      font-size: 1.2em;
      margin-bottom: 15px;
      color: #ffd700;
      text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
    }

    #victory p {
      font-size: 1.1em;
      margin-bottom: 15px;
      line-height: 1.4;
    }

    .controls-hint {
      font-size: 0.9em;
      opacity: 0.8;
      margin-top: 10px;
      font-style: italic;
    }

    #muteBtn {
      position: fixed;
      bottom: 10px;
      left: 10px;
      background: none;
      border: none;
      color: white;
      font-size: 32px;
      cursor: pointer;
      transition: all 0.3s;
      z-index: 1000;
      filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.5)) saturate(0.2);
      padding: 0;
      opacity: 0.5;
    }

    #muteBtn:hover, #muteBtn:active {
      transform: scale(1.1);
      opacity: 0.9;
      filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.5)) saturate(1);
    }

    #muteBtn.muted {
      opacity: 0.3;
    }

    #volumePopup {
      position: fixed;
      bottom: 55px;
      left: 10px;
      background: rgba(0, 0, 0, 0.85);
      backdrop-filter: blur(10px);
      border-radius: 10px;
      padding: 15px;
      z-index: 1001;
      display: none;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
      border: 1px solid rgba(255, 255, 255, 0.2);
    }

    #volumePopup.show {
      display: block;
      animation: popupAppear 0.2s ease-out;
    }

    @keyframes popupAppear {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    #volumePopup label {
      display: block;
      font-size: 0.9em;
      margin-bottom: 8px;
      color: white;
      text-align: center;
    }

    #volumeSlider {
      width: 120px;
      height: 6px;
      -webkit-appearance: none;
      background: rgba(255, 255, 255, 0.3);
      border-radius: 3px;
      outline: none;
    }

    #volumeSlider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 18px;
      height: 18px;
      background: #9b59d0;
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    }

    #volumeSlider::-moz-range-thumb {
      width: 18px;
      height: 18px;
      background: #9b59d0;
      border-radius: 50%;
      cursor: pointer;
      border: none;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    }

    #mobileControls {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: grid;
      grid-template-columns: repeat(3, 50px);
      grid-template-rows: repeat(3, 50px);
      gap: 6px;
      z-index: 1000;
    }

    .control-btn {
      background: rgba(0, 0, 0, 0.6);
      backdrop-filter: blur(10px);
      border: 2px solid rgba(255, 255, 255, 0.3);
      border-radius: 10px;
      color: white;
      font-size: 28px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      user-select: none;
      transition: all 0.2s;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
      line-height: 1;
      padding: 0 0 5px 0;
    }

    .unicorn-center {
      grid-column: 2;
      grid-row: 2;
      width: 50px;
      height: 50px;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .unicorn-center img {
      width: 40px;
      height: 40px;
      object-fit: contain;
      filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
    }

    .unicorn-center:active {
      transform: scale(0.95);
    }

    .unicorn-link {
      cursor: pointer;
    }

    .control-btn:active {
      background: rgba(100, 100, 255, 0.8);
      transform: scale(0.95);
    }

    .control-btn.up { grid-column: 2; grid-row: 1; }
    .control-btn.left { grid-column: 1; grid-row: 2; }
    .control-btn.down { grid-column: 2; grid-row: 3; }
    .control-btn.right { grid-column: 3; grid-row: 2; }

    #version {
      position: fixed;
      bottom: 10px;
      right: 10px;
      font-size: 0.7em;
      opacity: 0.4;
      color: white;
      z-index: 500;
      pointer-events: none;
    }

    @media (max-width: 600px) {
      h1 { font-size: 1.8em; }
      .tile { width: 38px; height: 38px; }
      .player { width: 46px; height: 46px; }
      .crystal { width: 26px; height: 26px; }
      .restore-point { width: 24px; height: 24px; }
    }
  </style>
</head>
<body>
  <!-- Background Music -->
  <audio id="bgMusic" loop preload="auto">
    <source src="Glitter%20Speedrun%20(0.42x).mp3" type="audio/mpeg">
  </audio>

  <!-- Mute Button -->
  <button id="muteBtn" title="Toggle Music (right-click for volume)">üîä</button>

  <!-- Volume Popup -->
  <div id="volumePopup">
    <label>Volume: <span id="volumeValue">50</span>%</label>
    <input type="range" id="volumeSlider" min="0" max="100" value="50">
  </div>

  <!-- Version Number -->
  <div id="version">v0.2.1</div>

  <div id="game">
    <div id="ui">
      <h1><img src="graphics/unicorn.png" alt="Unicorn" class="unicorn-link" onclick="window.open('https://happyunicornarmy.com', '_blank')">Rainbow Sokoban<a href="https://happyunicornarmy.com" target="_blank" class="site-link">happyunicornarmy.com</a></h1>
      <div id="levelInfo">Level <span id="levelNum">1</span>: <span id="levelName">Loading...</span></div>
      <div id="stats">
        Moves: <span id="moveCount">0</span> |
        Optimal: <span id="optimalMoves">0</span>
      </div>
      <div class="button-group">
        <button id="resetBtn">üîÑ Reset</button>
        <button id="prevBtn">‚Üê Previous</button>
        <button id="nextBtn">Next ‚Üí</button>
      </div>
    </div>
    <div id="grid"></div>

    <!-- Mobile Controls -->
    <div id="mobileControls">
      <button class="control-btn up" data-dir="up">‚Üë</button>
      <button class="control-btn left" data-dir="left">‚Üê</button>
      <div class="unicorn-center" onclick="window.open('https://happyunicornarmy.com', '_blank')">
        <img src="graphics/unicorn.png" alt="Happy Unicorn Army">
      </div>
      <button class="control-btn down" data-dir="down">‚Üì</button>
      <button class="control-btn right" data-dir="right">‚Üí</button>
    </div>
    <div id="victory" style="display:none">
      <h2>‚ú® Level Complete! ‚ú®</h2>
      <p id="victoryStats"></p>
      <div class="button-group">
        <button id="victoryResetBtn">üîÑ Retry</button>
        <button id="victoryNextBtn">Next Level ‚Üí</button>
      </div>
      <button id="victoryShareBtn" style="display:none; margin-top: 10px;">üì§ Share Results</button>
    </div>
  </div>

  <!-- Load levels from external file -->
  <script src="levels.js"></script>

  <script>
    // ===== GAME DATA =====
    // Levels are loaded from levels.js

    // ===== MUSIC SYSTEM =====

    const music = {
      audio: document.getElementById('bgMusic'),
      started: false,
      muted: localStorage.getItem('musicMuted') === 'true',
      volume: parseFloat(localStorage.getItem('musicVolume')) || 0.5
    };

    // Initialize music settings from localStorage
    function initMusic() {
      const muteBtn = document.getElementById('muteBtn');
      const volumeSlider = document.getElementById('volumeSlider');
      const volumeValue = document.getElementById('volumeValue');

      // Set volume from stored value
      music.audio.volume = music.volume;
      volumeSlider.value = Math.round(music.volume * 100);
      volumeValue.textContent = Math.round(music.volume * 100);

      if (music.muted) {
        music.audio.muted = true;
        muteBtn.textContent = 'üîá';
        muteBtn.classList.add('muted');
      } else {
        music.audio.muted = false;
        muteBtn.textContent = 'üîä';
        muteBtn.classList.remove('muted');
      }

      // Volume slider change handler
      volumeSlider.addEventListener('input', (e) => {
        const vol = parseInt(e.target.value) / 100;
        music.volume = vol;
        music.audio.volume = vol;
        volumeValue.textContent = e.target.value;
        localStorage.setItem('musicVolume', vol);

        // Auto-unmute if adjusting volume while muted
        if (music.muted && vol > 0) {
          music.muted = false;
          music.audio.muted = false;
          muteBtn.textContent = 'üîä';
          muteBtn.classList.remove('muted');
          localStorage.setItem('musicMuted', 'false');
        }
      });

      // Right-click on mute button shows volume popup
      muteBtn.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        toggleVolumePopup();
      });

      // Long-press on mute button for mobile
      let longPressTimer = null;
      muteBtn.addEventListener('touchstart', (e) => {
        longPressTimer = setTimeout(() => {
          e.preventDefault();
          toggleVolumePopup();
        }, 500);
      });
      muteBtn.addEventListener('touchend', () => {
        clearTimeout(longPressTimer);
      });
      muteBtn.addEventListener('touchmove', () => {
        clearTimeout(longPressTimer);
      });

      // Click outside closes popup
      document.addEventListener('click', (e) => {
        const popup = document.getElementById('volumePopup');
        const muteBtn = document.getElementById('muteBtn');
        if (!popup.contains(e.target) && e.target !== muteBtn) {
          popup.classList.remove('show');
        }
      });
    }

    function toggleVolumePopup() {
      const popup = document.getElementById('volumePopup');
      popup.classList.toggle('show');
    }

    // Start music on first user interaction
    function startMusicOnInteraction() {
      if (!music.started) {
        // Always start the music (respect mute state via audio.muted)
        music.audio.play().then(() => {
          music.started = true;
        }).catch(err => {
          // Will retry on next interaction
          console.log('Audio play prevented, will retry:', err);
        });
      }
    }

    // Toggle mute
    function toggleMute() {
      music.muted = !music.muted;
      music.audio.muted = music.muted;
      localStorage.setItem('musicMuted', music.muted);

      const muteBtn = document.getElementById('muteBtn');
      if (music.muted) {
        muteBtn.textContent = 'üîá';
        muteBtn.classList.add('muted');
      } else {
        muteBtn.textContent = 'üîä';
        muteBtn.classList.remove('muted');
        // If music hasn't started yet, start it when unmuting
        if (!music.started) {
          startMusicOnInteraction();
        }
      }

      // Close volume popup when toggling mute
      document.getElementById('volumePopup').classList.remove('show');
    }

    // ===== SOUND EFFECTS SYSTEM =====

    const sfx = {
      audioContext: null,
      initialized: false,
      volume: 0.5
    };

    // Initialize Web Audio API context (must be called after user interaction)
    function initSoundEffects() {
      if (sfx.initialized) return;
      try {
        sfx.audioContext = new (window.AudioContext || window.webkitAudioContext)();
        sfx.initialized = true;
        // Sync volume with music volume
        sfx.volume = music.volume;
      } catch (e) {
        console.log('Web Audio API not supported:', e);
      }
    }

    // Create an oscillator note
    function createNote(freq, startTime, duration, type = 'sine', gainValue = 0.3) {
      if (!sfx.audioContext || music.muted) return;

      const oscillator = sfx.audioContext.createOscillator();
      const gainNode = sfx.audioContext.createGain();

      oscillator.type = type;
      oscillator.frequency.setValueAtTime(freq, startTime);

      // Apply volume with envelope
      const effectiveGain = gainValue * sfx.volume;
      gainNode.gain.setValueAtTime(0, startTime);
      gainNode.gain.linearRampToValueAtTime(effectiveGain, startTime + 0.02);
      gainNode.gain.setValueAtTime(effectiveGain, startTime + duration - 0.05);
      gainNode.gain.linearRampToValueAtTime(0, startTime + duration);

      oscillator.connect(gainNode);
      gainNode.connect(sfx.audioContext.destination);

      oscillator.start(startTime);
      oscillator.stop(startTime + duration);

      return oscillator;
    }

    // Zelda-style "item get" chime when crystal is placed correctly
    function playCrystalPlacementSound(color) {
      initSoundEffects();
      if (!sfx.audioContext || music.muted) return;

      const now = sfx.audioContext.currentTime;

      // Color-based pitch variation (descending pitch through ROYGBIV)
      const colorPitchMap = {
        'red': 1.15,
        'orange': 1.10,
        'yellow': 1.05,
        'green': 1.0,
        'blue': 0.95,
        'indigo': 0.90,
        'violet': 0.85
      };
      const pitchMult = colorPitchMap[color] || 1.0;

      // Classic Zelda item jingle: quick ascending notes with a triumphant finish
      // Base frequencies for the jingle
      const baseFreqs = [523.25, 659.25, 783.99, 1046.50]; // C5, E5, G5, C6

      // Play the ascending arpeggio
      baseFreqs.forEach((freq, i) => {
        createNote(freq * pitchMult, now + i * 0.08, 0.15, 'sine', 0.25);
        // Add a subtle harmony
        createNote(freq * pitchMult * 1.5, now + i * 0.08, 0.12, 'sine', 0.1);
      });

      // Sparkle overtone at the end
      createNote(1318.51 * pitchMult, now + 0.32, 0.3, 'sine', 0.15);
    }

    // Triumphant fanfare for level completion
    function playLevelCompleteSound() {
      initSoundEffects();
      if (!sfx.audioContext || music.muted) return;

      const now = sfx.audioContext.currentTime;

      // Triumphant fanfare melody
      const fanfare = [
        // First phrase - attention grabber
        { freq: 523.25, time: 0, dur: 0.15 },      // C5
        { freq: 523.25, time: 0.12, dur: 0.15 },   // C5
        { freq: 523.25, time: 0.24, dur: 0.15 },   // C5
        { freq: 659.25, time: 0.40, dur: 0.35 },   // E5 (held)

        // Second phrase - rising
        { freq: 587.33, time: 0.80, dur: 0.15 },   // D5
        { freq: 659.25, time: 0.95, dur: 0.15 },   // E5
        { freq: 698.46, time: 1.10, dur: 0.15 },   // F5
        { freq: 783.99, time: 1.25, dur: 0.50 },   // G5 (held)

        // Finale - triumphant resolution
        { freq: 880.00, time: 1.80, dur: 0.20 },   // A5
        { freq: 987.77, time: 2.00, dur: 0.20 },   // B5
        { freq: 1046.50, time: 2.20, dur: 0.60 }, // C6 (triumphant finish)
      ];

      // Play main melody
      fanfare.forEach(note => {
        createNote(note.freq, now + note.time, note.dur, 'sine', 0.25);
      });

      // Add harmony layer (thirds below)
      const harmonyOffset = Math.pow(2, -4/12); // Major third below
      fanfare.forEach(note => {
        createNote(note.freq * harmonyOffset, now + note.time, note.dur, 'sine', 0.12);
      });

      // Add bass notes for depth
      const bassNotes = [
        { freq: 130.81, time: 0, dur: 0.40 },      // C3
        { freq: 146.83, time: 0.80, dur: 0.40 },   // D3
        { freq: 174.61, time: 1.80, dur: 0.80 },   // F3
      ];
      bassNotes.forEach(note => {
        createNote(note.freq, now + note.time, note.dur, 'triangle', 0.2);
      });

      // Shimmering finale chord
      const finaleChord = [1046.50, 1318.51, 1567.98]; // C6, E6, G6
      finaleChord.forEach(freq => {
        createNote(freq, now + 2.2, 0.8, 'sine', 0.15);
      });
    }

    // Extra special fanfare for final level (rainbow victory)
    function playRainbowVictorySound() {
      initSoundEffects();
      if (!sfx.audioContext || music.muted) return;

      const now = sfx.audioContext.currentTime;

      // Extended rainbow fanfare - more elaborate than regular victory
      const fanfare = [
        // Opening flourish
        { freq: 392.00, time: 0, dur: 0.12 },      // G4
        { freq: 493.88, time: 0.10, dur: 0.12 },   // B4
        { freq: 587.33, time: 0.20, dur: 0.12 },   // D5
        { freq: 783.99, time: 0.30, dur: 0.25 },   // G5

        // Main theme
        { freq: 659.25, time: 0.60, dur: 0.20 },   // E5
        { freq: 783.99, time: 0.80, dur: 0.20 },   // G5
        { freq: 880.00, time: 1.00, dur: 0.20 },   // A5
        { freq: 1046.50, time: 1.20, dur: 0.40 },  // C6

        // Rising rainbow scale
        { freq: 523.25, time: 1.70, dur: 0.10 },   // C5 - red
        { freq: 587.33, time: 1.80, dur: 0.10 },   // D5 - orange
        { freq: 659.25, time: 1.90, dur: 0.10 },   // E5 - yellow
        { freq: 698.46, time: 2.00, dur: 0.10 },   // F5 - green
        { freq: 783.99, time: 2.10, dur: 0.10 },   // G5 - blue
        { freq: 880.00, time: 2.20, dur: 0.10 },   // A5 - purple
        { freq: 987.77, time: 2.30, dur: 0.10 },   // B5 - pink

        // Grand finale
        { freq: 1046.50, time: 2.50, dur: 0.80 },  // C6
        { freq: 1318.51, time: 2.70, dur: 0.60 },  // E6
        { freq: 1567.98, time: 2.90, dur: 0.40 },  // G6
      ];

      fanfare.forEach(note => {
        createNote(note.freq, now + note.time, note.dur, 'sine', 0.22);
      });

      // Harmony
      fanfare.slice(4).forEach(note => {
        createNote(note.freq * 0.75, now + note.time, note.dur, 'sine', 0.1);
      });

      // Deep bass foundation
      createNote(65.41, now, 1.0, 'triangle', 0.25);  // C2
      createNote(87.31, now + 1.2, 1.0, 'triangle', 0.25);  // F2
      createNote(65.41, now + 2.5, 1.2, 'triangle', 0.3);  // C2

      // Sparkle overlay
      for (let i = 0; i < 8; i++) {
        const sparkleFreq = 2000 + Math.random() * 2000;
        createNote(sparkleFreq, now + 2.5 + i * 0.1, 0.15, 'sine', 0.05);
      }
    }

    // ===== SOKOBAN SOLVER =====

    function solveSokoban(levelData) {
      // BFS solver to find if level is solvable and optimal move count
      const { tiles, player, crystals, restorePoints } = levelData;

      // Create state key for visited tracking
      function stateKey(playerPos, crystalPositions) {
        const cKey = crystalPositions
          .map(c => `${c.x},${c.y}`)
          .sort()
          .join('|');
        return `${playerPos.x},${playerPos.y}|${cKey}`;
      }

      // Check if state is winning
      function isWin(crystalPositions) {
        return crystalPositions.every(crystal => {
          return restorePoints.some(
            rp => rp.x === crystal.x && rp.y === crystal.y && rp.color === crystal.color
          );
        });
      }

      // Check if position is walkable
      function isWalkable(x, y) {
        if (x < 0 || y < 0 || y >= tiles.length || x >= tiles[0].length) return false;
        return tiles[y][x] === 0;
      }

      // BFS queue: {player, crystals, moves}
      const queue = [{
        player: { ...player },
        crystals: crystals.map(c => ({ ...c })),
        moves: 0
      }];

      const visited = new Set();
      visited.add(stateKey(player, crystals));

      const directions = [
        { dx: 0, dy: -1 }, // up
        { dx: 0, dy: 1 },  // down
        { dx: -1, dy: 0 }, // left
        { dx: 1, dy: 0 }   // right
      ];

      let iterations = 0;
      const MAX_ITERATIONS = 200000; // Prevent infinite loops

      while (queue.length > 0 && iterations++ < MAX_ITERATIONS) {
        const state = queue.shift();

        if (isWin(state.crystals)) {
          return { solvable: true, moves: state.moves };
        }

        // Try each direction
        for (const { dx, dy } of directions) {
          const newX = state.player.x + dx;
          const newY = state.player.y + dy;

          if (!isWalkable(newX, newY)) continue;

          // Check if there's a crystal at new position
          const crystalIndex = state.crystals.findIndex(c => c.x === newX && c.y === newY);

          if (crystalIndex !== -1) {
            // Try to push crystal
            const pushX = newX + dx;
            const pushY = newY + dy;

            if (!isWalkable(pushX, pushY)) continue;

            // Check if another crystal is blocking
            const blocked = state.crystals.some(c => c.x === pushX && c.y === pushY);
            if (blocked) continue;

            // Create new state with pushed crystal
            const newCrystals = state.crystals.map((c, i) =>
              i === crystalIndex ? { ...c, x: pushX, y: pushY } : { ...c }
            );
            const newPlayer = { x: newX, y: newY };
            const key = stateKey(newPlayer, newCrystals);

            if (!visited.has(key)) {
              visited.add(key);
              queue.push({
                player: newPlayer,
                crystals: newCrystals,
                moves: state.moves + 1
              });
            }
          } else {
            // Just move player
            const newPlayer = { x: newX, y: newY };
            const key = stateKey(newPlayer, state.crystals);

            if (!visited.has(key)) {
              visited.add(key);
              queue.push({
                player: newPlayer,
                crystals: state.crystals.map(c => ({ ...c })),
                moves: state.moves + 1
              });
            }
          }
        }
      }

      return { solvable: false, moves: -1 };
    }

    // ===== GAME STATE =====

    const game = {
      level: 0,
      moves: 0,
      grid: {
        width: 0,
        height: 0,
        tiles: []
      },
      player: { x: 0, y: 0, facing: 'right' },
      crystals: [],
      restorePoints: [],
      isMoving: false,
      isComplete: false,
      completedLevels: JSON.parse(localStorage.getItem('completedLevels') || '[]'),
      levelStars: JSON.parse(localStorage.getItem('levelStars') || '{}')
    };

    // ===== CORE FUNCTIONS =====

    function loadLevel(levelIndex) {
      if (levelIndex < 0 || levelIndex >= levels.length) return;

      const level = levels[levelIndex];

      game.level = levelIndex;
      game.moves = 0;
      game.isComplete = false;
      game.isMoving = false;

      game.grid.width = level.width;
      game.grid.height = level.height;
      game.grid.tiles = level.tiles.map(row => [...row]);

      game.player = { ...level.player, facing: 'right' };
      game.crystals = level.crystals.map(c => ({ ...c, activated: false }));
      game.restorePoints = level.restorePoints.map(r => ({ ...r, active: false }));

      // Reset victory screen customizations
      document.getElementById('victory').style.display = 'none';
      document.getElementById('victoryResetBtn').style.display = 'block';
      document.getElementById('victoryShareBtn').style.display = 'none';
      document.body.classList.remove('rainbow-victory');

      updateUI();
      renderGrid();
      updateButtons();
    }

    function renderGrid() {
      const gridEl = document.getElementById('grid');
      gridEl.innerHTML = '';
      gridEl.style.gridTemplateColumns = `repeat(${game.grid.width}, 45px)`;

      for (let y = 0; y < game.grid.height; y++) {
        for (let x = 0; x < game.grid.width; x++) {
          const tile = document.createElement('div');
          tile.className = 'tile';
          tile.dataset.x = x;
          tile.dataset.y = y;

          const tileType = game.grid.tiles[y][x];
          if (tileType === 1) tile.classList.add('wall');
          if (tileType === 2) tile.classList.add('water');
          if (tileType === 3) tile.classList.add('ice');

          // Add restore points
          const rp = game.restorePoints.find(r => r.x === x && r.y === y);
          if (rp) {
            const rpEl = document.createElement('div');
            rpEl.className = `restore-point ${rp.color}`;
            if (rp.active) rpEl.classList.add('active');
            tile.appendChild(rpEl);
          }

          // Add crystals
          const crystal = game.crystals.find(c => c.x === x && c.y === y);
          if (crystal) {
            const crystalEl = document.createElement('div');
            crystalEl.className = `crystal ${crystal.color}`;
            if (crystal.activated) crystalEl.classList.add('activated');
            tile.appendChild(crystalEl);
          }

          // Add player
          if (game.player.x === x && game.player.y === y) {
            const playerEl = document.createElement('img');
            playerEl.className = 'player';
            playerEl.src = 'graphics/unicorn.png';
            playerEl.alt = 'Unicorn';
            // Flip horizontally when facing right
            if (game.player.facing === 'right') {
              playerEl.style.transform = 'scaleX(-1)';
            }
            tile.appendChild(playerEl);
          }

          gridEl.appendChild(tile);
        }
      }
    }

    function updateUI() {
      document.getElementById('levelNum').textContent = game.level + 1;
      document.getElementById('levelName').textContent = levels[game.level].name;
      document.getElementById('moveCount').textContent = game.moves;
      document.getElementById('optimalMoves').textContent = levels[game.level].optimalMoves;
    }

    function updateButtons() {
      document.getElementById('prevBtn').disabled = game.level === 0;
      // Can only go to next level if current or previous level is completed
      const canGoNext = game.level < levels.length - 1 &&
                        (game.completedLevels.includes(game.level) || game.level === 0);
      document.getElementById('nextBtn').disabled = !canGoNext;
    }

    function markLevelComplete(stars) {
      if (!game.completedLevels.includes(game.level)) {
        game.completedLevels.push(game.level);
        localStorage.setItem('completedLevels', JSON.stringify(game.completedLevels));
        updateButtons();
      }
      // Save best stars for this level (only if better than previous)
      const currentBest = game.levelStars[game.level] || 0;
      if (stars > currentBest) {
        game.levelStars[game.level] = stars;
        localStorage.setItem('levelStars', JSON.stringify(game.levelStars));
      }
    }

    function tryMove(dx, dy) {
      if (game.isMoving || game.isComplete) return;

      const newX = game.player.x + dx;
      const newY = game.player.y + dy;

      if (!isInBounds(newX, newY)) return;
      if (!isWalkable(newX, newY)) return;

      const crystal = getCrystalAt(newX, newY);

      if (crystal) {
        const pushX = newX + dx;
        const pushY = newY + dy;

        if (!canPushTo(pushX, pushY)) return;

        crystal.x = pushX;
        crystal.y = pushY;
        crystal.activated = false;
      }

      game.player.x = newX;
      game.player.y = newY;
      game.moves++;

      // Update facing direction based on horizontal movement
      if (dx < 0) game.player.facing = 'left';
      if (dx > 0) game.player.facing = 'right';

      updateRestorePoints();
      updateUI();
      renderGrid();
      checkWin();
    }

    function isInBounds(x, y) {
      return x >= 0 && x < game.grid.width && y >= 0 && y < game.grid.height;
    }

    function isWalkable(x, y) {
      if (!isInBounds(x, y)) return false;
      const tile = game.grid.tiles[y][x];
      return tile === 0 || tile === 3; // 0 = walkable, 3 = ice
    }

    function getCrystalAt(x, y) {
      return game.crystals.find(c => c.x === x && c.y === y);
    }

    function canPushTo(x, y) {
      return isWalkable(x, y) && !getCrystalAt(x, y);
    }

    function updateRestorePoints() {
      game.restorePoints.forEach(rp => {
        const crystal = getCrystalAt(rp.x, rp.y);
        const wasActive = rp.active;
        rp.active = crystal && crystal.color === rp.color;

        if (rp.active && !wasActive && crystal) {
          crystal.activated = true;
          // Play the Zelda-style crystal placement chime
          playCrystalPlacementSound(crystal.color);
        }
      });
    }

    function checkWin() {
      const allActive = game.restorePoints.every(rp => rp.active);

      if (allActive && game.restorePoints.length > 0) {
        game.isComplete = true;
        setTimeout(showVictory, 300);
      }
    }

    function showVictory() {
      const optimal = levels[game.level].optimalMoves;
      let stars = 1;
      const isOptimal = game.moves <= optimal;
      if (isOptimal) stars = 3;
      else if (game.moves <= optimal * 1.5) stars = 2;

      markLevelComplete(stars);

      const starStr = '‚≠ê'.repeat(stars);

      const isLastLevel = game.level === levels.length - 1;

      // Extra celebration for optimal solution!
      if (isOptimal && !isLastLevel) {
        createOptimalCelebration();
      }

      // Special rainbow finale message
      if (isLastLevel) {
        document.getElementById('victoryStats').innerHTML = `
          <h2 style="font-size: 2.5em; margin: 15px 0;">üåà</h2>
          <strong style="font-size: 1.4em; background: linear-gradient(to right, #f44336, #ff9800, #ffc107, #4caf50, #2196f3, #3F51B5, #9c27b0); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;">RAINBOW VICTORY!</strong><br><br>
          <strong>Moves:</strong> ${game.moves}<br>
          <strong>Optimal:</strong> ${optimal}<br>
          <strong>Stars:</strong> ${starStr}<br><br>
          <em>You've mastered all the colors!</em>
        `;
        createRainbowCelebration();
        // Play the special rainbow victory fanfare
        playRainbowVictorySound();
        // Activate rainbow background
        document.body.classList.add('rainbow-victory');
        // Hide retry button on final level
        document.getElementById('victoryResetBtn').style.display = 'none';
        // Change the Next button to Happy Unicorn Army
        const nextBtn = document.getElementById('victoryNextBtn');
        nextBtn.textContent = 'Happy Unicorn Army';
        nextBtn.onclick = () => window.open('https://happyunicornarmy.com', '_blank');
        nextBtn.disabled = false;
        // Show share button on final level
        document.getElementById('victoryShareBtn').style.display = 'block';
      } else {
        document.getElementById('victoryStats').innerHTML = `
          <strong>Moves:</strong> ${game.moves}<br>
          <strong>Optimal:</strong> ${optimal}<br>
          <strong>Stars:</strong> ${starStr}
        `;
        // Play the level complete fanfare
        playLevelCompleteSound();
      }

      document.getElementById('victory').style.display = 'block';

      // Reset the Next button if not on last level
      if (!isLastLevel) {
        const nextBtn = document.getElementById('victoryNextBtn');
        nextBtn.textContent = 'Next Level ‚Üí';
        nextBtn.disabled = false;
        nextBtn.onclick = () => {
          if (game.level + 1 < levels.length) {
            loadLevel(game.level + 1);
          }
        };
      }
    }

    // ===== SHARE FUNCTIONALITY =====

    function generateShareText() {
      const totalStars = Object.values(game.levelStars).reduce((sum, s) => sum + s, 0);
      const maxStars = levels.length * 3;

      let text = 'üåà Rainbow Quest Complete! ü¶Ñ\n\n';

      levels.forEach((level, i) => {
        const stars = game.levelStars[i] || 0;
        const starEmojis = '‚≠ê'.repeat(stars) + '‚òÜ'.repeat(3 - stars);
        // Clean level name (remove emojis for cleaner share text)
        const cleanName = level.name.replace(/üåà/g, '').trim();
        text += `${starEmojis} ${cleanName}\n`;
      });

      text += `\n‚ú® Total: ${totalStars}/${maxStars} stars\n`;
      text += '\nü¶Ñ https://happyunicornarmy.com/rainbow-quest';

      return text;
    }

    async function shareResults() {
      const shareText = generateShareText();

      // Try Web Share API first (works on mobile)
      if (navigator.share) {
        try {
          await navigator.share({
            title: 'Rainbow Quest - My Results',
            text: shareText
          });
          return;
        } catch (err) {
          // User cancelled or share failed, fall through to clipboard
          if (err.name === 'AbortError') return;
        }
      }

      // Fallback to clipboard
      try {
        await navigator.clipboard.writeText(shareText);
        const btn = document.getElementById('victoryShareBtn');
        const originalText = btn.textContent;
        btn.textContent = '‚úì Copied!';
        setTimeout(() => { btn.textContent = originalText; }, 2000);
      } catch (err) {
        // Final fallback - show in a prompt
        prompt('Copy your results:', shareText);
      }
    }

    function createRainbowCelebration() {
      const colors = ['#f44336', '#ff9800', '#ffc107', '#4caf50', '#2196f3', '#3F51B5', '#9c27b0'];

      for (let i = 0; i < 50; i++) {
        setTimeout(() => {
          const x = Math.random() * window.innerWidth;
          const y = Math.random() * window.innerHeight;
          const color = colors[Math.floor(Math.random() * colors.length)];
          const size = Math.random() * 15 + 10;

          const particle = document.createElement('div');
          particle.style.position = 'fixed';
          particle.style.left = x + 'px';
          particle.style.top = y + 'px';
          particle.style.width = size + 'px';
          particle.style.height = size + 'px';
          particle.style.borderRadius = '50%';
          particle.style.background = color;
          particle.style.zIndex = '9999';
          particle.style.pointerEvents = 'none';
          particle.style.boxShadow = `0 0 ${size}px ${color}`;

          document.body.appendChild(particle);

          const duration = Math.random() * 2000 + 2000;
          const dy = Math.random() * 200 + 100;

          particle.animate([
            { transform: 'translateY(0)', opacity: 1 },
            { transform: `translateY(${dy}px)`, opacity: 0 }
          ], {
            duration: duration,
            easing: 'ease-out'
          });

          setTimeout(() => particle.remove(), duration);
        }, i * 50);
      }
    }

    function createOptimalCelebration() {
      // Gold burst for optimal solution!
      for (let i = 0; i < 30; i++) {
        setTimeout(() => {
          const x = Math.random() * window.innerWidth;
          const y = Math.random() * window.innerHeight;
          const size = Math.random() * 20 + 15;

          const particle = document.createElement('div');
          particle.style.position = 'fixed';
          particle.style.left = x + 'px';
          particle.style.top = y + 'px';
          particle.style.width = size + 'px';
          particle.style.height = size + 'px';
          particle.style.borderRadius = '50%';
          particle.style.background = 'radial-gradient(circle, #ffd700, #ffed4e)';
          particle.style.zIndex = '9999';
          particle.style.pointerEvents = 'none';
          particle.style.boxShadow = `0 0 ${size * 2}px #ffd700`;

          document.body.appendChild(particle);

          const duration = Math.random() * 1500 + 1500;
          const dy = Math.random() * 300 + 150;

          particle.animate([
            { transform: 'translateY(0) scale(1)', opacity: 1 },
            { transform: `translateY(${dy}px) scale(0.5)`, opacity: 0 }
          ], {
            duration: duration,
            easing: 'ease-out'
          });

          setTimeout(() => particle.remove(), duration);
        }, i * 30);
      }
    }

    // ===== EVENT LISTENERS =====

    document.addEventListener('keydown', (e) => {
      // Try to start music on any keypress
      startMusicOnInteraction();

      // Check if victory screen is showing
      const victoryVisible = document.getElementById('victory').style.display !== 'none';

      if (victoryVisible && e.key === 'Enter') {
        e.preventDefault();
        // Go to next level if available
        if (game.level + 1 < levels.length) {
          loadLevel(game.level + 1);
        }
        return;
      }

      switch(e.key.toLowerCase()) {
        case 'arrowup':
        case 'w':
          e.preventDefault();
          tryMove(0, -1);
          break;
        case 'arrowdown':
        case 's':
          e.preventDefault();
          tryMove(0, 1);
          break;
        case 'arrowleft':
        case 'a':
          e.preventDefault();
          tryMove(-1, 0);
          break;
        case 'arrowright':
        case 'd':
          e.preventDefault();
          tryMove(1, 0);
          break;
        case 'r':
          e.preventDefault();
          loadLevel(game.level);
          break;
      }
    });

    document.getElementById('resetBtn').onclick = () => {
      startMusicOnInteraction();
      loadLevel(game.level);
    };
    document.getElementById('prevBtn').onclick = () => {
      startMusicOnInteraction();
      loadLevel(game.level - 1);
    };
    document.getElementById('nextBtn').onclick = () => {
      startMusicOnInteraction();
      loadLevel(game.level + 1);
    };
    document.getElementById('victoryResetBtn').onclick = () => {
      startMusicOnInteraction();
      loadLevel(game.level);
    };
    document.getElementById('victoryNextBtn').onclick = () => {
      startMusicOnInteraction();
      if (game.level + 1 < levels.length) {
        loadLevel(game.level + 1);
      }
    };
    document.getElementById('victoryShareBtn').onclick = () => {
      shareResults();
    };

    // Mute button
    document.getElementById('muteBtn').onclick = () => {
      startMusicOnInteraction();
      toggleMute();
    };

    // Mobile controls
    document.querySelectorAll('.control-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        startMusicOnInteraction();
        const dir = e.target.dataset.dir;
        switch(dir) {
          case 'up': tryMove(0, -1); break;
          case 'down': tryMove(0, 1); break;
          case 'left': tryMove(-1, 0); break;
          case 'right': tryMove(1, 0); break;
        }
      });
    });

    // ===== LEVEL VERIFICATION =====
    function verifyAllLevels() {
      console.log('üîç Verifying all levels...');
      levels.forEach((level, index) => {
        const result = solveSokoban({
          tiles: level.tiles,
          player: level.player,
          crystals: level.crystals,
          restorePoints: level.restorePoints
        });

        if (result.solvable) {
          console.log(`‚úÖ Level ${index + 1} "${level.name}": SOLVABLE in ${result.moves} moves (stated optimal: ${level.optimalMoves})`);
        } else {
          console.error(`‚ùå Level ${index + 1} "${level.name}": UNSOLVABLE!`);
        }
      });
      console.log('‚ú® Verification complete!');
    }

    // ===== INITIALIZE =====
    initMusic();
    loadLevel(0);

    // Start music on any first interaction (click, touch, or keypress)
    function setupFirstInteraction() {
      const removeHandlers = () => {
        document.removeEventListener('click', handler);
        document.removeEventListener('touchstart', handler);
        document.removeEventListener('keydown', handler);
      };
      const handler = () => {
        music.audio.play().then(() => {
          music.started = true;
          removeHandlers();
        }).catch(() => {
          // Keep listeners active to retry on next interaction
        });
      };
      document.addEventListener('click', handler);
      document.addEventListener('touchstart', handler);
      document.addEventListener('keydown', handler);
    }
    setupFirstInteraction();

    // Verify levels in background (disabled - solver gives false negatives for complex levels)
    // setTimeout(verifyAllLevels, 1000);
  </script>
</body>
</html>
